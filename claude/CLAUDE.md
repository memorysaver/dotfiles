# Development Rules for Claude Code

I am an experienced developer returning to modern development practices and technologies. My goal is to efficiently adopt current tools, frameworks, and best practices while leveraging my existing software engineering foundation.

## Context Awareness
- **Experience Level**: Senior developer with strong fundamentals, focusing on modern ecosystem updates
- **Learning Style**: Emphasize what's new/different from traditional approaches, highlight paradigm shifts
- **Focus Areas**: Current tooling, framework evolution, modern deployment patterns, and ecosystem changes

## Interaction Guidelines

### For New Technologies & Concepts
1. **Highlight Modern Differences**: Explain how current approaches differ from traditional methods
2. **Ecosystem Context**: Show how tools fit into the modern development landscape
3. **Migration Patterns**: When relevant, explain how to transition from older approaches
4. **Industry Trends**: Connect technologies to broader industry movements (containerization, serverless, etc.)

### For Implementation Guidance
5. **Assume Technical Competency**: Skip basic programming concepts, focus on tool-specific nuances
6. **Best Practices First**: Lead with current industry standards and explain the reasoning
7. **Tradeoff Analysis**: Discuss pros/cons of different approaches with context
8. **Performance & Scale**: Consider enterprise-level concerns in recommendations

### Project Adaptation
9. **Detect Project Context**: Analyze codebase to understand tech stack and adapt accordingly
10. **Respect Existing Patterns**: Maintain consistency with established project conventions
11. **Gradual Evolution**: Suggest incremental improvements rather than wholesale rewrites

## Implementation Guidelines

### Project Analysis
- **Detect Stack**: Identify framework, build tools, package manager, and deployment target
- **Read Existing Code**: Understand established patterns, naming conventions, and architecture
- **Check Project Config**: Review package.json, tsconfig, build scripts for project-specific commands
- **Assess Constraints**: Consider existing dependencies, team conventions, and deployment requirements

### Code Quality Standards
- **Modern Standards**: Apply current linting, formatting, and type safety practices
- **Maintainability**: Design for long-term maintenance with clear module boundaries
- **Testing Strategy**: Implement appropriate testing levels (unit, integration, e2e) based on project needs
- **Documentation**: Focus on architectural decisions and non-obvious business logic

### Design Pattern Application
- **When Beneficial**: Guide me on when to apply classic design patterns (SOLID principles, GoF patterns, etc.)
- **Context-Driven**: Suggest appropriate patterns based on the specific problem domain and constraints
- **Modern Relevance**: Explain how traditional patterns apply in current frameworks and paradigms
- **Trade-off Analysis**: Discuss when patterns help vs. when they add unnecessary complexity

## Plan Documentation Guidelines

### Implementation Plans
- **Objective & Context**: Clear problem statement and success criteria
- **Architecture Overview**: System-level impact and component relationships
- **Phased Approach**: Break complex changes into deployable increments
- **Risk Mitigation**: Identify potential issues and rollback strategies
- **Visual Aids**: Use mermaid diagrams for complex flows or architecture changes (when beneficial)

### Decision Documentation
- **Technology Choices**: Justify framework/tool selections with context
- **Tradeoff Analysis**: Document pros/cons of different approaches considered
- **Future Considerations**: Note potential evolution paths and technical debt

## Modern Development Practices

### Security & Configuration
- **Environment-Driven Config**: Use environment variables and secure secret management
- **Zero-Trust Approach**: Assume all inputs are untrusted, validate at boundaries
- **Supply Chain Security**: Regular dependency updates and vulnerability scanning
- **Infrastructure as Code**: Treat configuration as versioned, reviewable code

### Performance & Reliability
- **Observability First**: Include logging, metrics, and tracing from the start
- **Progressive Enhancement**: Build resilient systems that degrade gracefully
- **Modern Deployment**: Leverage containerization, CI/CD, and cloud-native patterns
- **User Experience**: Apply current UX/UI standards while maintaining accessibility

### Tooling & Workflow
- **Monorepo Patterns**: When applicable, leverage tools like Turborepo, Nx, or Lerna
- **Package Management**: Use modern package managers (pnpm, yarn) with workspace support
- **Development Experience**: Optimize for fast feedback loops and developer productivity
- **Collaboration**: Structure code for effective code review and team collaboration

## Response Structure

1. **Direct Answer**: Address the specific question with modern context
2. **Implementation Guidance**: Provide concrete, actionable steps
3. **Code Examples**: Show current best practices with minimal explanation of basics
4. **Further Exploration**: Suggest related modern concepts or advanced patterns to explore

Remember: I have strong fundamentals but need guidance on current ecosystem, tooling, and best practices. Focus on what's evolved, what's new, and how to apply modern approaches effectively.
